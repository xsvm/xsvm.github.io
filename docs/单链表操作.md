# 单链表操作

## 1. 单链表的创建
### 1.1 单链表的结构定义
在C++中，我们使用结构体来定义单链表的节点结构：
```cpp
using namespace std;

typedef int ElemType;      // 定义数据类型
typedef struct LNode {
    ElemType data;         // 数据域
    struct LNode *next;    // 指向后继结点的指针
} LinkNode;               // 单链表结点类型
```

### 1.2 头插法创建单链表
头插法是将新节点插入到链表的头部，使新节点成为第一个节点。
```cpp
void CreateListF(LinkNode *&L, ElemType a[], int n) {
    L = new LinkNode;      // 创建头结点
    L->next = nullptr;     // 初始化为空链表
    
    for (int i = 0; i < n; i++) {
        LinkNode *s = new LinkNode;  // 创建新结点
        s->data = a[i];             // 赋值数据域
        s->next = L->next;          // 将结点s插在原开始结点之前,头结点之后
        L->next = s;
    }
}
```

### 1.3 尾插法创建单链表
尾插法是将新节点插入到链表的尾部，保持元素的顺序与数组中的顺序一致。
```cpp
void CreateListR(LinkNode *&L, ElemType a[], int n) {
    L = new LinkNode;      // 创建头结点
    L->next = nullptr;
    LinkNode *r = L;       // r始终指向终端结点,开始时指向头结点
    
    for (int i = 0; i < n; i++) {
        LinkNode *s = new LinkNode;  // 创建新结点
        s->data = a[i];             // 赋值数据域
        r->next = s;                // 将结点s插入结点r之后
        r = s;                      // r指向新的终端结点
    }
    r->next = nullptr;             // 终端结点next域置为nullptr
}
```

## 2. 单链表的基本操作
### 2.1 初始化空链表
```cpp
void InitList(LinkNode *&L) {
    L = new LinkNode;      // 创建头结点
    L->next = nullptr;     // 头结点的next域置为nullptr
}
```

### 2.2 销毁链表
```cpp
void DestroyList(LinkNode *&L) {
    LinkNode *pre = L, *p = pre->next;
    while (p != nullptr) {
        delete pre;        // 释放pre结点
        pre = p;          // pre移动到下一个结点
        p = pre->next;    // p移动到下一个结点
    }
    delete pre;          // 最后释放尾结点
}
```

### 2.3 判断链表是否为空
```cpp
bool ListEmpty(LinkNode *L) {
    return (L->next == nullptr);
}
```

### 2.4 计算链表长度
```cpp
int ListLength(LinkNode *L) {
    LinkNode *p = L;
    int i = 0;
    while (p->next != nullptr) {
        i++;
        p = p->next;
    }
    return i;
}
```

### 2.5 遍历输出链表
```cpp
void DispList(LinkNode *L) {
    LinkNode *p = L->next;
    while (p != nullptr) {
        cout << p->data << " ";
        p = p->next;
    }
    cout << endl;
}
```

## 3. 单链表的元素操作
### 3.1 按位置查找元素
```cpp
bool GetElem(LinkNode *L, int i, ElemType &e) {
    if (i <= 0) return false;   // i值不合法
    
    LinkNode *p = L;
    int j = 0;
    while (j < i && p != nullptr) {
        j++;
        p = p->next;
    }
    
    if (p == nullptr)          // 不存在第i个数据结点
        return false;
    else {                     // 存在第i个数据结点
        e = p->data;
        return true;
    }
}
```

### 3.2 按元素值查找位置
```cpp
int LocateElem(LinkNode *L, ElemType e) {
    LinkNode *p = L->next;
    int n = 1;
    while (p != nullptr && p->data != e) {
        p = p->next;
        n++;
    }
    if (p == nullptr)
        return 0;           // 未找到返回0
    else
        return n;           // 返回位置
}
```

### 3.3 插入元素
```cpp
bool ListInsert(LinkNode *&L, int i, ElemType e) {
    if (i <= 0) return false;   // i值不合法
    
    LinkNode *p = L;
    int j = 0;
    while (j < i-1 && p != nullptr) {  // 查找第i-1个结点
        j++;
        p = p->next;
    }
    
    if (p == nullptr)                  // 未找到第i-1个结点
        return false;
    else {                             // 找到第i-1个结点
        LinkNode *s = new LinkNode;    // 创建新结点
        s->data = e;
        s->next = p->next;            // 将s结点插入到结点p之后
        p->next = s;
        return true;
    }
}
```

### 3.4 删除元素
```cpp
bool ListDelete(LinkNode *&L, int i, ElemType &e) {
    if (i <= 0) return false;   // i值不合法
    
    LinkNode *p = L;
    int j = 0;
    while (j < i-1 && p != nullptr) {  // 查找第i-1个结点
        j++;
        p = p->next;
    }
    
    if (p == nullptr)                  // 未找到第i-1个结点
        return false;
    else {                             // 找到第i-1个结点p
        LinkNode *q = p->next;         // q指向要删除的结点
        if (q == nullptr)
            return false;              // 若不存在第i个结点,返回false
        e = q->data;
        p->next = q->next;            // 从单链表中删除q结点
        delete q;                      // 释放q结点
        return true;
    }
}
```
## 图解
![单链表操作图解](/单链表操作.png)