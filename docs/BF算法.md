# BF算法

## 算法简介
BF算法（Brute Force），也称为**暴力**匹配算法，是一种简单但效率较低的字符串匹配算法。它的基本思想是从主串的第一个字符开始，依次与模式串的字符进行比较，如果匹配成功，则继续比较下一个字符，直到模式串完全匹配成功；如果匹配失败，则主串回退到下一个待匹配位置，模式串重新从头开始匹配。

c++中string类的成员函数find()用于在字符串中查找子串，其原型就算BF算法

### 时间复杂度
BF算法的时间复杂度为O(m*n)，其中m为主串的长度，n为模式串的长度。在实际应用中，BF算法的效率较低，通常只用于小规模的字符串匹配问题。
## 算法原理
BF算法的核心思想是在主串中依次查找与模式串匹配的子串。具体来说，它从主串的第一个字符开始，依次与模式串的字符进行比较，如果匹配成功，则继续比较下一个字符，直到模式串完全匹配成功；如果匹配失败，则主串回退到下一个待匹配位置，模式串重新从头开始匹配。

### 匹配过程
1. 从主串的第一个字符开始，依次与模式串的字符进行比较。
2. 如果匹配成功，则继续比较下一个字符，直到模式串完全匹配成功。
3. 如果匹配失败，则主串回退到下一个待匹配位置，模式串重新从头开始匹配。

`下一个待匹配位置 = 当前主串位置 - 已匹配长度 + 1`

4. 重复步骤2和3，直到模式串完全匹配成功或主串遍历完成为止。

## 算法实现
S为主串，T为模式串（要查找的字串），pos为开始匹配的位置（一般是0）
```cpp
int BF(string S, string T, int pos) {
    int i = pos;
    int j = 0;
    
    while (i < S.length() && j < T.length()) {
        if (S[i] == T[j]) {    // 字符匹配，继续比较下一个字符
            i++;
            j++;
        } else {               // 字符不匹配，主串回退，模式串重新开始
            i = i - j + 1;     // 主串回退到下一个待匹配位置
            j = 0;             // 模式串重新从头开始匹配
        }
    }
    
    if (j >= T.length())       // 模式串完全匹配
        return i - T.length(); // 返回匹配的起始位置
    else                       // 匹配失败
        return -1;             // 返回-1表示未找到匹配
}
```

## 案例
主串 S = "ABCDEF"
模式串 T = "CDE"
初始位置 pos = 0
```
第一轮匹配（从位置0开始）：
S: A B C D E F
   ↑
T: C D E
   ↑
匹配1: A≠C ✗ （失配）

下个位置：`i-j+1=0-0+1=1`

第二轮匹配（从位置1开始）：
S: A B C D E F
     ↑
T: C D E
   ↑
匹配1: B≠C ✗ （失配）

下个位置：`i-j+1=1-0+1=2`

第三轮匹配（从位置2开始）：
S: A B C D E F
       ↑
T: C D E
   ↑
匹配1: C=C ✓

S: A B C D E F
       ↑ ↑
T: C D E
   ↑ ↑
匹配2: D=D ✓

S: A B C D E F
       ↑ ↑ ↑
T: C D E
   ↑ ↑ ↑
匹配3: E=E ✓

匹配成功，返回起始位置2
```
