# 75. 颜色分类（荷兰国旗问题）
## 题目
**难度：中等**

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，[原地](https://baike.baidu.com/item/原地算法)对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

**提示：**

*   `n == nums.length`
*   `1 <= n <= 300`
*   `nums[i]` 为 `0`、`1` 或 `2`

**进阶：**

*   你能想出一个仅使用常数空间的一趟扫描算法吗？

## 题目理解与思路

这道题要求我们将一个包含0（红色）、1（白色）、2（蓝色）的数组进行原地排序，使得相同颜色的元素相邻，并按照红、白、蓝的顺序排列。

使用三个指针来将数组划分为三个部分：

1.  **`p0` 指针**：维护数组最左边的0序列的右边界。让`[0, p0-1]` 区间内的元素都是0。
2.  **`curr` 指针**：当前遍历到的元素位置。
3.  **`p2` 指针**：维护数组最右边的2序列的左边界。让`[p2+1, n-1]` 区间内的元素都是2。

我们的目标是使得 `[0, p0-1]` 都是0，`[p0, p2]` 之间在遍历过程中是未处理或已处理为1的元素，而 `[p2+1, n-1]` 都是2。

遍历过程 (`curr <= p2`)：
*   当 `nums[curr] == 0` 时：将 `nums[curr]` 与 `nums[p0]` 交换，然后 `p0` 和 `curr` 都向右移动一位。因为交换过来的 `nums[p0]` 之前是在 `p0` 左边或者就是 `p0` 本身，它要么是0要么是1，如果是0，`curr` 移到下一个继续判断；如果是1，`curr` 下一轮会判断它。
*   当 `nums[curr] == 1` 时：`curr` 直接向右移动一位，因为1就在它应该在的中间区域。
*   当 `nums[curr] == 2` 时：将 `nums[curr]` 与 `nums[p2]` 交换，然后 `p2` 向左移动一位。注意，此时 `curr` 不动！，因为从 `p2` 交换过来的元素 `nums[curr]` 还没有被处理，需要下一轮循环继续判断当前 `curr` 位置的元素。

循环终止条件是 `curr > p2`，此时排序完成。

## 答案

```cpp
class Solution {
public:
    void sortColors(std::vector<int>& nums) {
        int n = nums.size();
        if (n < 2) {
            return;
        }
        int p0 = 0, curr = 0;
        int p2 = n - 1;
        while (curr <= p2) {
            if (nums[curr] == 0) {
                std::swap(nums[curr++], nums[p0++]);
            } else if (nums[curr] == 2) {
                std::swap(nums[curr], nums[p2--]);
            } else {
                curr++;
            }
        }
    }
};
```