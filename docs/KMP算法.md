# KMP算法
## 1. 简介
`KMP算法`（Knuth-Morris-Pratt）是一种改进的字符串匹配算法，由Donald Knuth、James H. Morris和Vaughan Pratt三人于1977年共同发表。与`BF算法`相比，KMP算法通过利用已经部分匹配这个有效信息，保持主串的指针不回溯，从而大大提高了匹配效率。
### 1.1 时间复杂度
KMP算法的时间复杂度为O(m+n)，其中m为主串（T）长度，n为模式串(P)长度。这比BF算法的O(m*n)要高效得多。
## 2. 原理
KMP算法的核心思想是利用模式串的**前缀和后缀**信息，在匹配失败时，通过已知的部分匹配信息，尽可能地减少模式串的回溯次数。这个信息被存储在一个叫做`next数组`（或"失配函数"）的数组中。
### 2.1 next数组
next数组是KMP算法的关键，它记录了模式串中每个位置的**最长相等**前后缀长度：
- 对于模式串的每个位置i，`next[i]`表示**模式串 P 的子串 `P[0...i]`** 中，**最长**的相等的**真前缀**和**真后缀**的长度。
- 这个信息用来指导在匹配失败时，模式串应该回退到什么位置继续匹配。
对于模式串"ABABC"：
`位置i:     0  1  2  3  4`
`模式串:    A  B  A  B  C`
`next[i]: [-1  0  1  2  0]`
- next[0] = -1，表示模式串的第一个字符没有真前缀和真后缀。
- next[1] = 0，子串"AB"，真前缀{"A"}，真后缀{"B"}，没有相等的。
- next[2] = 1，子串"ABA"，真前缀{"A", "AB"}，真后缀{"A", "BA"}，最长相等的是"A"，长度为1。
- next[3] = 2，子串"ABAB"，真前缀{"A", "AB", "ABA"}，真后缀{"B", "AB", "BAB"}，最长相等的是"AB"，长度为2。
- next[4] = 0，子串"ABABC"，真前缀{"A", "AB", "ABA", "ABAB"}，真后缀{"C", "BC", "ABC", "BABC"}，没有相等的。

### 2.2 匹配过程
KMP算法的匹配过程利用 `next` 数组来避免主串指针的回溯。假设主串为 `T`，模式串为 `P`，`n` 为主串长度，`m` 为模式串长度。使用两个指针 `i` 和 `j`，分别指向主串 `T` 和模式串 `P` 的当前比较位置。

1.  **初始化**: `i = 0`, `j = 0`。
2.  **循环比较**: 当 `i < n` 时，执行以下步骤：
    *   **情况一：匹配成功或 j 为 -1**: 如果 `j == -1` (表示需要从模式串的开头重新比较) 或者 `T[i] == P[j]`，则两个指针都向前移动一位，即 `i++`, `j++`。
    *   **情况二：匹配失败**: 如果 `T[i] != P[j]`，并且 `j > -1`，则主串指针 `i` **不回溯**，模式串指针 `j` 根据 `next` 数组移动到下一个可能匹配的位置，即 `j = next[j]`。这利用了已匹配前缀的信息，将模式串向右滑动到合适的位置。
3.  **判断是否找到匹配**: 在每次 `i++` 和 `j++` 之后，检查 `j` 是否等于 `m`。如果 `j == m`，说明模式串 `P` 已经完全匹配主串中以 `i - m` 开头的一段子串。此时，可以记录下匹配位置 `i - m`。如果需要查找所有匹配，可以让 `j` 回退到 `next[j-1]` (根据 `next` 数组的定义，这里可能需要调整为 `next[j]` 或 `next[m-1]` 等，取决于具体实现和 `next` 数组的含义，使用我们之前定义的 `next` 数组 `[-1, 0, 1, 2, 0]`，当 `j==m` 时，下一个 `j` 应该设为 `next[j-1]` 即 `next[4]=0`，以便继续查找下一个可能的匹配)。如果只需要找第一个匹配，可以直接结束。
4.  **循环结束**: 当 `i` 到达主串末尾 (`i == n`) 时，匹配过程结束。

**示例**:
主串 T = "ABABDABABC"
模式串 P = "ABABC"
next 数组 = [-1, 0, 1, 2, 0]

- i=0, j=0: T[0]='A', P[0]='A'. 匹配. i=1, j=1.
- i=1, j=1: T[1]='B', P[1]='B'. 匹配. i=2, j=2.
- i=2, j=2: T[2]='A', P[2]='A'. 匹配. i=3, j=3.
- i=3, j=3: T[3]='B', P[3]='B'. 匹配. i=4, j=4.
- i=4, j=4: T[4]='D', P[4]='C'. **不匹配**. j > -1，令 `j = next[j] = next[4] = 0`.
- i=4, j=0: T[4]='D', P[0]='A'. **不匹配**. j > -1，令 `j = next[j] = next[0] = -1`.
- i=4, j=-1: j == -1. 匹配 (特殊情况). i=5, j=0.
- i=5, j=0: T[5]='A', P[0]='A'. 匹配. i=6, j=1.
- i=6, j=1: T[6]='B', P[1]='B'. 匹配. i=7, j=2.
- i=7, j=2: T[7]='A', P[2]='A'. 匹配. i=8, j=3.
- i=8, j=3: T[8]='B', P[3]='B'. 匹配. i=9, j=4.
- i=9, j=4: T[9]='C', P[4]='C'. 匹配. i=10, j=5.
- **j == m (模式串长度)**. 找到匹配，起始位置为 `i - j = 10 - 5 = 5`.
- (若需继续查找) 令 `j = next[j-1] = next[4] = 0`.
- i=10. 循环结束 (i == n).

最终在主串索引 5 处找到模式串 "ABABC"。

## 3. 核心代码实现

```c++ next数组的计算
// 计算模式串P的next数组
vector<int> getNext(const string& P) {
    int m = P.length();
    vector<int> next(m);
    next[0] = -1;  // 初始化next[0]为-1
    int j = -1;    // j表示前缀末尾
    int i = 0;     // i表示后缀末尾
    
    // 通过已知的next[0,...,i-1]计算next[i]
    while (i < m - 1) { // 注意循环终止条件避免越界
        if (j == -1 || P[i] == P[j]) {
            i++;
            j++;
            next[i] = j;
        } else {
            j = next[j];
        }
    }
    return next;
}
```

```c++ KMP算法的实现
int kmp(const string& T, const string& P) {
    int n = T.length();
    int m = P.length();
    vector<int> next = getNext(P);
    int i = 0, j = 0;
    
    while (i < n && j < m) {
        if (j == -1 || T[i] == P[j]) { // 匹配成功或重置后
            i++;
            j++;
        } else {                       // 匹配失败时滑动模式串
            j = next[j];
        }
    }
    
    if (j == m) { // 找到匹配
        return i - j;
    } else {      // 未找到匹配
        return -1;
    }
}
```