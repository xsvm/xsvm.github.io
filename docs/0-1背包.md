# 01背包
## 问题描述
有 $N$ 件物品和一个体积为 $M$ 的背包。第 $i$ 个物品的体积为 $v_i$，价值为 $w_i$。每件物品只能使用一次。
请问可以通过什么样的方式选择物品，使得物品总体积不超过 $M$ 的情况下总价值最大，输出这个最大价值即可。

## 输入格式
第一行输入两个正整数 $N,M$。$(1≤N,M≤1000)$
接下来 $N$ 行，每行输入两个整数 $v_i,w_i$。$(0≤v_i,w_i≤1000)$

## 输出格式
输出一个整数，表示符合题目要求的最大价值。

## 样例输入
```
4 5
1 2
2 4
3 4
4 5
```

## 样例输出
```
8
```

## 说明

你可以选择第二个物品和第三个物品。

## 题解

### 1. 动态规划解法

01背包是一个经典的动态规划问题。我们需要对每个物品做出选择：要么选，要么不选。

#### 状态定义

定义dp[i][j]表示：考虑前i个物品，背包容量为j时能获得的最大价值。

#### 状态转移方程

对于第i个物品，我们有两种选择：

1. 不选择第i个物品：dp[i][j] = dp[i-1][j]
2. 选择第i个物品：dp[i][j] = dp[i-1][j-v[i]] + w[i]

最终的状态转移方程为：
dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])

### 2. 代码实现
#### 二维数组实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm> //max函数
using namespace std;

int main() {
    int N, M;
    cin >> N >> M;

    vector<int> v(N), w(N);
    for (int i = 0; i < N; i++) {
        cin >> v[i] >> w[i];
    }

    // dp[i][j] 表示考虑前 i 个物品 (物品索引从1到N)，背包容量为 j 时的最大价值
    // 为了方便物品索引与dp数组索引对应，大小设为 (N+1)x(M+1)
    vector<vector<int>> dp(N + 1, vector<int>(M + 1, 0));

    for (int i = 1; i <= N; i++) { // 遍历物品 (第i个物品对应 v[i-1], w[i-1])
        for (int j = 0; j <= M; j++) { // 遍历背包容量
            // 不选择第 i 个物品
            dp[i][j] = dp[i-1][j];
            // 如果可以选择第 i 个物品 (即当前容量 j 大于等于物品 i 的体积 v[i-1])
            if (j >= v[i-1]) {
                dp[i][j] = max(dp[i][j], dp[i-1][j - v[i-1]] + w[i-1]);
            }
        }
    }

    cout << dp[N][M] << endl;
    return 0;
}
```

#### 一维数组优化
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N, M;
    cin >> N >> M;
  
    // 使用vector来存储物品的体积和价值
    vector<int> v(N), w(N);
    for(int i = 0; i < N; i++) {
        cin >> v[i] >> w[i];
    }
  
    // dp数组，使用一维数组优化空间复杂度
    vector<int> dp(M + 1, 0);
    
    // 处理每个物品
    for(int i = 0; i < N; i++) {
        // 必须从后向前遍历，否则会重复使用同一物品
        for(int j = M; j >= v[i]; j--) {
            // 状态转移：选择或不选择第i个物品
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
            // dp[j] 的当前值表示不选物品i时的最大价值 (继承自上一轮)
            // dp[j - v[i]] + w[i] 表示选择物品i时的最大价值
        }
    }
    cout << dp[M] << endl;
    return 0;
}
```

### 3. 讲解

1. **数据存储**：使用STL中的vector来存储物品的体积(v)和价值(w)，方便管理内存。
2. **空间优化**：

   - 原始的dp方程需要二维数组dp[N+1][M+1]
   - 观察发现每个状态只依赖于上一行的数据
   - 使用一维数组dp[M+1]，从后向前更新，可以达到同样效果
3. **遍历顺序**：

   - 外层循环遍历物品
   - 内层循环必须从大到小遍历容量
   - 这样保证每个物品只被使用一次
4. **状态转移**：

   - dp[j] = max(dp[j], dp[j-v[i]]+w[i])
   - dp[j]代表不选第i个物品
   - dp[j-v[i]]+w[i]代表选第i个物品

### 4. 复杂度分析

- 时间复杂度：O(N×M)，其中N是物品数量，M是背包容量
- 空间复杂度：O(M)，使用一维数组优化后只需要M的空间
