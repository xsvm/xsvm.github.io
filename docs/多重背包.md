# 多重背包问题

## 问题描述
有 $N$ 件物品和一个体积为 $M$ 的背包。第 $i$ 个物品的体积为 $v_i$，价值为 $w_i$。每件物品只能使用 $c_i$ 次。

请问可以通过什么样的方式选择物品，使得物品总体积不超过 $M$ 的情况下总价值最大，输出这个最大价值即可。

## 输入格式
第一行输入两个正整数 $N,M$。$(1≤N,M≤100)$

接下来 $N$ 行，每行输入三个整数 $v_i,w_i,c_i$。$(0≤v_i,w_i,c_i≤100)$

## 输出格式
输出一个整数，表示符合题目要求的最大价值。

## 样例输入
```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

## 样例输出
```
10
```

## 题解
多重背包问题是01背包问题的扩展，每种物品有指定的数量限制。我们可以使用一维数组来优化空间复杂度。

### 1. 基本思路
1. 使用一维数组dp[j]表示容量为j时能获得的最大价值
2. 对于每个物品i，我们最多可以选择ci次
3. 为了避免重复计算，我们需要从大到小遍历背包容量

### 2. 代码实现
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    // N表示物品种类数，M表示背包容量
    int N, M;
    cin >> N >> M;
    // v数组存储每个物品的体积，w数组存储每个物品的价值，c数组存储每个物品的数量
    vector<int> v(N), w(N), c(N);
    for (int i = 0; i < N; ++i) {
        cin >> v[i] >> w[i] >> c[i];
    }

    // dp[j]表示背包容量为j时能获得的最大价值
    vector<int> dp(M + 1, 0);
    // 外层循环遍历每种物品
    for (int i = 0; i < N; ++i) {
        // 中层循环从大到小遍历背包容量，避免重复计算同一物品
        // 必须从大到小遍历，因为每个物品最多选c[i]个，如果从小到大会导致一个物品被重复选择超过限制次数
        for (int j = M; j >= 0; --j) {
            // 内层循环枚举当前物品选择的个数k
            // k不能超过物品i的数量限制c[i]，且k个物品的总体积k*v[i]不能超过当前背包容量j
            for (int k = 1; k <= c[i] && k * v[i] <= j; ++k) {
                // 状态转移方程：dp[j]表示不选第i个物品时的最大价值
                // dp[j - k * v[i]] + k * w[i]表示选择k个第i个物品时的最大价值
                dp[j] = max(dp[j], dp[j - k * v[i]] + k * w[i]);
            }
        }
    }

    cout << dp[M] << endl;
    return 0;
}
```

### 3. 代码讲解
1. 数组定义：
   - dp[j]：表示背包容量为j时能获得的最大价值
   - v[i]、w[i]、c[i]：分别表示第i个物品的体积、价值和数量

2. 核心思路：
   - 外层循环遍历每个物品
   - 中层循环从大到小遍历背包容量（避免重复计算）
   - 内层循环尝试放入不同数量的当前物品

3. 状态转移：
   - dp[j] = max(dp[j], dp[j - k * v[i]] + k * w[i])
   - k表示放入第i种物品的数量，不超过c[i]且总体积不超过j

### 4. 复杂度
- 总时间复杂度：O(N×M×C)，其中C是物品数量的最大值
- 空间复杂度：O(M)，只使用了一维数组