# 桶排序 (Bucket Sort)

## 算法思想

桶排序（Bucket Sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。

**基本思想：**

1.  **设置固定数量的桶：** 根据待排序数据的范围和分布，设置一定数量的桶（`bucket_count`）。
2.  **元素入桶：** 遍历原始数组，将每个元素根据其值（或通过一个映射函数）分配到对应的桶中。
    *   映射函数的设计是关键，它决定了元素如何均匀地分布到各个桶中。一个简单的映射函数可以是 `(element_value - min_value) / bucket_range`，其中 `bucket_range` 是每个桶所覆盖的值的范围。
3.  **桶内排序：** 对每个非空的桶内部的元素进行排序。可以使用其他排序算法（如插入排序）或者递归调用桶排序。
4.  **合并结果：** 按照桶的顺序，依次将每个桶内已排序的元素合并起来，形成最终的有序序列。

**关键点：**

*   桶排序的效率依赖于输入数据能均匀地分配到各个桶中。如果数据分布极不均匀，例如所有数据都落入同一个桶，那么桶排序的性能会退化到桶内排序算法的性能。
*   适用于数据分布相对均匀的情况。

## 复杂度

-   时间复杂度：
    -   平均：O(n + k)，其中 n 是元素数量，k 是桶的数量。当元素被均匀分配到桶中，且桶内排序高效时（例如桶内元素少，插入排序接近O(m)，m为桶内元素数量）。如果桶内排序使用比较排序，则为 O(n + n²/k + k)。
    -   最坏：O(n²)，当所有元素都落入同一个桶中，且桶内排序使用 O(n²) 的算法时。
    -   最好：O(n + k)，当元素均匀分布时。
-   空间复杂度：O(n + k) (需要额外的空间存储桶和桶内元素)
-   稳定性：取决于桶内排序算法的稳定性。如果桶内排序是稳定的，并且元素按顺序放入桶和从桶中取出，则桶排序是稳定的。

## LeetCode 题目：前 K 个高频元素 (Top K Frequent Elements)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

**提示：**

*   `1 <= nums.length <= 10⁵`
*   `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
*   题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

**进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

**解题思路提示 (使用桶排序思想)：**

1.  统计每个数字出现的频率 (可以使用哈希表)。
2.  频率的范围是 `[1, nums.length]`。我们可以将频率作为桶的索引。
3.  创建一个桶数组，`buckets[i]` 存储所有出现频率为 `i` 的数字。
4.  从后向前遍历桶数组（从最高频率开始），收集元素，直到收集到 `k` 个元素。

## 题解

```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 统计每个数字的频率
        unordered_map<int, int> freq;
        for(int num : nums) {
            freq[num]++;
        }
        
        // 创建桶，桶的下标表示频率，桶中存储具有相同频率的数字
        vector<vector<int>> buckets(nums.size() + 1);
        for(auto [num, count] : freq) {
            buckets[count].push_back(num);
        }
        
        // 从后向前遍历桶，收集前k个高频元素
        vector<int> result;
        for(int i = buckets.size() - 1; i >= 0 && result.size() < k; i--) {
            for(int num : buckets[i]) {
                result.push_back(num);
                if(result.size() == k) break;
            }
        }
        
        return result;
    }
};
```