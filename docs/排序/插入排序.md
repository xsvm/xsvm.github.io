# 插入排序 (Insertion Sort)

## 算法思想

插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

**具体步骤：**

1.  从第一个元素开始，该元素可以认为已经被排序。
2.  取出下一个元素，在已经排序的元素序列中从后向前扫描。
3.  如果该元素（已排序）大于新元素，将该元素移到下一位置。
4.  重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。
5.  将新元素插入到该位置后。
6.  重复步骤2~5。

## 复杂度

-   时间复杂度：
    -   平均：O(n²)
    -   最坏：O(n²) (当数组逆序时)
    -   最好：O(n) (当数组已经有序时)
-   空间复杂度：O(1)
-   稳定性：稳定

## LeetCode 题目：排序数组 (Sort an Array)

给你一个整数数组 `nums`，请你将该数组升序排列。

**示例 1：**

```
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
```

**示例 2：**

```
输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
```

**提示：**

*   `1 <= nums.length <= 5 * 10⁴`
*   `-5 * 10⁴ <= nums[i] <= 5 * 10⁴`

**注意：** 题目要求 `O(n log n)` 时间复杂度和最小的空间复杂度，插入排序的时间复杂度为 `O(n²)`，不符合最优解要求，但可以作为练习。

## 题解

```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        // 使用插入排序
        for(int i = 1; i < nums.size(); i++) {
            int key = nums[i];
            int j = i - 1;
            
            // 将比key大的元素都向后移动一位
            while(j >= 0 && nums[j] > key) {
                nums[j + 1] = nums[j];
                j--;
            }
            
            // 将key插入到正确的位置
            nums[j + 1] = key;
        }
        
        return nums;
    }
};
```