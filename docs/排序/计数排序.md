# 计数排序 (Counting Sort)

## 算法思想

计数排序（Counting Sort）是一种非比较型整数排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

**基本思想：**

1.  **找出待排序的数组中最大和最小的元素**，以确定计数数组的范围。
2.  **统计数组中每个值为 `i` 的元素出现的次数**，存入数组 `C` 的第 `i` 项（`C` 通常称为计数数组或桶）。
3.  **对所有的计数进行累加**（从 `C` 中的第一个元素开始，每一项和前一项相加）。修改后的 `C[i]` 表示小于或等于 `i` 的元素的数量。
4.  **反向填充目标数组：** 从右到左扫描原始数组，对于原始数组中的每个元素 `arr[j]`，其在新数组中的正确位置是 `C[arr[j]] - 1`。将 `arr[j]` 放入新数组的这个位置，然后将 `C[arr[j]]` 减 1。

**简化版 (适用于元素值范围较小且不需要稳定排序的场景，例如本题)：**

1.  找出待排序数组中最大值 `max_val` (如果知道元素范围，例如0, 1, 2，则可以直接使用)。
2.  创建一个计数数组 `count_array`，大小为 `max_val + 1`，并初始化所有元素为0。
3.  遍历原始数组，对于每个元素 `num`，增加 `count_array[num]` 的计数。
4.  遍历计数数组，根据每个元素的计数值，按顺序将元素写回原始数组。

## 复杂度

-   时间复杂度：O(n + k)
    -   n 是输入数组的长度。
    -   k 是整数的范围（最大值 - 最小值 + 1）。
    -   当 k 不是远大于 n 时，可以认为是 O(n)。
-   空间复杂度：O(k) (需要额外的空间存储计数数组)
-   稳定性：稳定 (标准实现，通过累加计数和反向填充可以保证稳定性)

## LeetCode 题目：颜色分类 (Sort Colors)

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库的sort函数的情况下解决这个问题。

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

**提示：**

*   `n == nums.length`
*   `1 <= n <= 300`
*   `nums[i]` 为 `0`、`1` 或 `2`

**进阶：**

*   你能想出一个仅使用常数额外空间的一趟扫描算法吗？ (提示：可以使用双指针法，但这超出了计数排序的范畴)

## 题解

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        // 由于只有0、1、2三种颜色，可以使用计数排序
        vector<int> count(3, 0);
        
        // 统计每种颜色的数量
        for(int num : nums) {
            count[num]++;
        }
        
        // 根据统计结果重写原数组
        int index = 0;
        for(int i = 0; i < 3; i++) {
            while(count[i] > 0) {
                nums[index++] = i;
                count[i]--;
            }
        }
    }
};
```