# 希尔排序 (Shell Sort)

## 算法思想

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

1.  插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。
2.  但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（所以效率很高）。

**具体步骤：**

1.  选择一个增量序列 `t1, t2, ..., tk` ，其中 `ti > tj`, `tk = 1`。
2.  按增量序列个数 `k`，对序列进行 `k` 趟排序。
3.  每趟排序，根据对应的增量 `ti`，将待排序列分割成若干长度为 `m` 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

常用的增量序列有：

*   Shell增量序列: `N/2, N/4, ..., 1` (N为数据规模)
*   Knuth增量序列: `1, 4, 13, ..., (3^k - 1) / 2`
*   Sedgewick增量序列: `1, 5, 19, 41, 109, ...`

## 复杂度

-   时间复杂度：平均时间复杂度取决于增量序列的选择。常见的结论有：
    -   对于Shell增量序列，最坏为 O(n²)，平均为 O(n log n) 到 O(n²) 之间，依赖于具体实现和数据。
    -   对于一些优化的增量序列，可以达到 O(n log² n) 或 O(n^(3/2))。
-   空间复杂度：O(1)
-   稳定性：不稳定

## LeetCode 题目：排序数组 (Sort an Array)

给你一个整数数组 `nums`，请你将该数组升序排列。

**示例 1：**

```
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
```

**示例 2：**

```
输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
```

**提示：**

*   `1 <= nums.length <= 5 * 10⁴`
*   `-5 * 10⁴ <= nums[i] <= 5 * 10⁴`

**注意：** 题目要求 `O(n log n)` 时间复杂度和最小的空间复杂度。希尔排序的平均时间复杂度可以接近 `O(n log n)`，但最坏情况下仍为 `O(n²)`。

## 题解

```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int n = nums.size();
        
        // 使用希尔排序，初始间隔设为n/2，每次减半
        for(int gap = n/2; gap > 0; gap /= 2) {
            // 对每个子序列进行插入排序
            for(int i = gap; i < n; i++) {
                int temp = nums[i];
                int j = i;
                
                // 在子序列中进行插入排序
                while(j >= gap && nums[j - gap] > temp) {
                    nums[j] = nums[j - gap];
                    j -= gap;
                }
                
                nums[j] = temp;
            }
        }
        
        return nums;
    }
};
```