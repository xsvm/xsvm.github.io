# 冒泡排序 (Bubble Sort)

## 算法思想

冒泡排序是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序排列，反之亦然）。

**具体步骤：**

1.  比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。
2.  对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3.  针对所有的元素重复以上的步骤，除了最后一个。
4.  持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

## 复杂度

-   时间复杂度：
    -   平均：O(n²)
    -   最坏：O(n²)
    -   最好：O(n) (当数组已经有序时)
-   空间复杂度：O(1)
-   稳定性：稳定

## LeetCode 题目：有序数组的平方 (Squares of a Sorted Array)

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2：**

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

**提示：**

*   `1 <= nums.length <= 10⁴`
*   `-10⁴ <= nums[i] <= 10⁴`
*   `nums` 已按 **非递减顺序** 排序

**进阶：**

请你设计时间复杂度为 `O(n)` 的算法解决本问题

## 题解

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        // 先对每个数字求平方
        for(int i = 0; i < nums.size(); i++) {
            nums[i] = nums[i] * nums[i];
        }
        
        // 使用冒泡排序
        for(int i = 0; i < nums.size() - 1; i++) {
            bool swapped = false;
            for(int j = 0; j < nums.size() - 1 - i; j++) {
                if(nums[j] > nums[j+1]) {
                    swap(nums[j], nums[j+1]);
                    swapped = true;
                }
            }
            // 如果一轮中没有发生交换，说明数组已经有序
            if(!swapped) break;
        }
        
        return nums;
    }
};
```